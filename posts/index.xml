<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Benson Li&#39;s Blog</title>
        <link>https://bbli.github.io/posts/</link>
        <description>Recent content in Posts on Benson Li&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Sun, 01 May 2022 00:00:00 -0700</lastBuildDate>
        <atom:link href="https://bbli.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>On the Cost of Code Resuse</title>
            <link>https://bbli.github.io/posts/on_cost_of_code_reuse/</link>
            <pubDate>Sun, 01 May 2022 00:00:00 -0700</pubDate>
            
            <guid>https://bbli.github.io/posts/on_cost_of_code_reuse/</guid>
            <description>Increases Compile Times -&amp;gt; Lowers Programmer Productivity  Why Compile Time is Important How Code Reuse affects Compile Time   Harder to Change and doesn&amp;rsquo;t always create Higher Level Abstractions Harder to Understand/Debug Final Thoughts  Increases Compile Times -&amp;gt; Lowers Programmer Productivity (Preface: This section will be in the context of C++, though the points will generally apply to other programming languages as well.)
Why Compile Time is Important Because no matter how smart you think you are, you will write bugs.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><a href="#increases-compile-times-lowers-programmer-productivity">Increases Compile Times -&gt; Lowers Programmer Productivity</a>
<ul>
<li><a href="#why-compile-time-is-important">Why Compile Time is Important</a></li>
<li><a href="#how-code-reuse-affects-compile-time">How Code Reuse affects Compile Time</a></li>
</ul>
</li>
<li><a href="#harder-to-change-and-doesn-t-always-create-higher-level-abstractions">Harder to Change and doesn&rsquo;t always create Higher Level Abstractions</a></li>
<li><a href="#harder-to-understand-debug">Harder to Understand/Debug</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
</ul>
<!-- raw HTML omitted -->
<h1 id="increases-compile-times-lowers-programmer-productivity">Increases Compile Times -&gt; Lowers Programmer Productivity</h1>
<p>(Preface: This section will be in the context of C++, though the points will generally apply to other programming languages as well.)</p>
<h2 id="why-compile-time-is-important">Why Compile Time is Important</h2>
<p>Because no matter how smart you think you are, you will write bugs. Iteration, experimentation, actually running your code is king in programming. So what happens when compile times start to take too long?</p>
<ol>
<li>Well, you will start to amortize changes before rerunning tests. This will make it harder to debug, because will not be caught early on, and so there can be times when the cause of a unit test failure at a particular call site actually happens earlier on in the call stack</li>
<li>There will be less test coverage: If compiling my code and running the tests takes say, over 20 minutes each time, I am significantly less likely to througouhly test it, opting instead to cover just the &ldquo;happy path&rdquo; and a bit more. This is because in the real world, there are deadlines to meet.</li>
<li>The shorter the compile time, the more you will be in the flow state. The issue is that as humans, it is hard for us to completely suspend our train of thoughts while we wait for the compiler. And so typically what happens is that we try to find some other task to do during the &ldquo;downtime&rdquo;. The issue with this is that after the compile is done, we have to bring back into working memory the original line of thinking. When compile times are short, we never need to &ldquo;<a href="https://stackoverflow.com/a/59414141">flush our brain&rsquo;s cache</a>&rdquo;.</li>
<li>Hotfixes will be more stressful, as you will spend more time under stress because of the long compiles.</li>
</ol>
<h2 id="how-code-reuse-affects-compile-time">How Code Reuse affects Compile Time</h2>
<p>(Preface: This will be in the context of C++, though the idea applies to other programming languages as well, even if the terminology and extent of the effect may be different)</p>
<p>Often times, we will import the entire header of a library just for the sake of calling 1 or 2 functions. This has the effect of not only forcing us to parse unnesscary lines of code from that header, <strong>but all headers it includes recursively</strong>. But it gets even worse. If that header was not from a third-party library but rather internal/from the codebase itself, then anytime a change happens in the header, all files that depend on it are forced to recompile, and so the average incremental compilation will go up. If instead, however, we define the functions ourselves, we parse exactly what we need and no more. So the next time you think about importing yet another library with <code>npm</code>, consider whether or not you can write the function yourself.</p>
<h1 id="harder-to-change-and-doesn-t-always-create-higher-level-abstractions">Harder to Change and doesn&rsquo;t always create Higher Level Abstractions</h1>
<p>An example of when code reuse gets you in trouble is the &ldquo;Fragile Base Class&rdquo; problem. In an effort to reuse the code from class A, we inherit from it in class B. The issue with this is that A no longer obeys the Single Responsibility Principle. Class A not only needs to maintain the correctness of its public interface, but also the correctness of all the methods and class invariants that B depends on/should continue to enforce.</p>
<p>And this applies to every subsequent class that inherits from A or B. What eventually happens, once your inheritance hierarchy is deep enough, is that when changing a method in a parent class, you break the functionality of a child class, with the classic example being the <a href="https://en.wikipedia.org/wiki/Fragile%5Fbase%5Fclass">infinite recursion error</a>. One can argue this is an issue caused by virtual methods, but the idea is still the same even without virtual methods and without classes. Everytime you change a function, you need to check all the call sites to make sure the function is still valid. And so for the same reason that abstracting into a function reduces code maintence in the future by removing redundancy(and thus changes to the function propagate automatically to all the call sites) <strong>it can increase code maintence for the exact same reason</strong>: changes to the function to satisfy the call site at location 1 inadvertently spread to all the other call sites too. What was once the same piece of functionality is now different.</p>
<p>But that said, there&rsquo;s actually a good fix for this: copy paste the function into a new one, change the bit that you need to change, and call the new function at location 1 instead of the old one. Unfortunately, what people tend to do is to modify the old function to fit in the &ldquo;new&rdquo; logic, which is evident by code smell of additonal &ldquo;boolean flags&rdquo; to the function signature. The issue with this is that the function can quickly become scattered with if statments, leading to <a href="https://martinfowler.com/bliki/FlagArgument.html">&ldquo;tangled logic&rdquo;</a>. And perhaps at a more philosophical level, the function becomes more about resusing code structure(like a macro) than about reusing/creating higher level abstractions. For a concrete example of this, consider the &ldquo;fold/reduce&rdquo; function in many programming languages. It has been purported to make code higher level and more &ldquo;declarative&rdquo;. But does it though? Consider the following example.</p>
<pre><code class="language-rust">// Implementation 1
let sum1 = vec.clone().into_iter()
    .reduce(|accum, item | {
            if pred(item){ accum+1 } else{ accum }
        });
// Implementation 2
let sum2 = vec.clone().into_iter()
    .count_if(|item|pred(*item))
// Implementation 3
let mut accum: i32 = 0;
for item in vec {
    if pred(item) {accum+=1}
}
</code></pre>
<p>When I read the for loop implemenation(Implementation 3), I have to read what is inside the for loop to understand what the code is doing, make it supposedly &ldquo;low level&rdquo;. But when I read the fold function implemenation &hellip; I still have to read the lambda to understand what is going on. While I believe in Sean Parent&rsquo;s statement in &ldquo;<a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">no raw loops</a>&rdquo;,  I do not believe <code>reduce</code> is the solution to this. Rather, one should functions such as <code>count_if</code>, which is more restrictive than <code>reduce</code> and thus better expresses intent. <code>count_if</code> is declarative. <code>reduce</code> is not.</p>
<h1 id="harder-to-understand-debug">Harder to Understand/Debug</h1>
<p>Suppose we are reading log files from a production server to debug an issue, and we see</p>
<pre><code class="language-cpp">void helper_function(Object&amp; oranges){
    log_line(&quot;2nd log line&quot;,oranges.string());
    // ...
}
void func(){
    log_line(&quot;first log line&quot;);
    // ...
    helper_function(apples);
    // ...
}
// In the logs, we see
// [INFO] first log line
// ... stuff
// [INFO] 2nd log line, apples(weight:10)
// ... stuff2
// [INFO] 2nd log line, apples(weight:20)
</code></pre>
<p>This can happen if in between <code>log_line</code> and <code>helper_function</code>, another function calls out to <code>helper_function</code>. But now the issue arises, which log line corresponds to the call by <code>func</code>? Perhaps by examing the local call path of logs, you can disambiguate. But if there is a lot of log lines inbetween(aka <code>stuff2</code>), you may not even realize that there was a duplicate!</p>
<p>Another concern is the mapping of variable names through the call path. In the code above I purposely created a naming mismatch between the function signature and the object passed in by <code>func</code>. Although it usually is not that extreme, helper function tend to have different variable names, and it requires a non-trivial effort to keep this mapping in mind, especially for multiple variables across multiple depths. When trying to understand a codebase, you can forget your original purpose after making 3-5 &ldquo;jump to definition&rdquo; calls to your IDE/language server because of this, and also because while you were trying to understand something &ldquo;specific&rdquo;, the callpath brings you out to something more &ldquo;general&rdquo;, just for the sake of this &ldquo;code reuse&rdquo;.</p>
<h1 id="final-thoughts">Final Thoughts</h1>
<p>Now, there are certainly benefits of code reuse. It can save time from needing to reimplement. Reusing code can also mean using code that someone has already tested. It can also allow programmers who are not experts on a certain subject to nevertheless write code for that domain. But as I hope this article shows, code reuse is not a &ldquo;zero-cost&rdquo; thing. So the next time you see code duplication in your codebase and want to refactor, be wary that you are not simply &ldquo;seeing faces in the clouds&rdquo;. As Sandi Metz has said: <a href="https://sandimetz.com/blog/2016/1/20/the-wrong-abstraction">&ldquo;Code duplication is far cheaper than the wrong abstraction&rdquo;</a>. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>.</p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>See <a href="https://news.ycombinator.com/item?id=12061453">https://news.ycombinator.com/item?id=12061453</a> for more discussion about this&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
        </item>
        
        <item>
            <title>Clarifying CRTP with the C&#43;&#43; object model</title>
            <link>https://bbli.github.io/posts/crtp_with_object_model/</link>
            <pubDate>Thu, 20 May 2021 19:36:00 -0700</pubDate>
            
            <guid>https://bbli.github.io/posts/crtp_with_object_model/</guid>
            <description>1How CRTP works 2CRTP is not &amp;ldquo;template programming magic&amp;rdquo; 3We already have static polymorphism 4We already have static implementation inheritance&amp;hellip;Except 5Appendix-Dynamic Dispatch  On my first encounter, the Curiously Recurring Template Pattern seemed like magic to me. Apparently, by writing static_cast&amp;lt;T*&amp;gt;(this)-&amp;gt;func(), we now have &amp;ldquo;static polymorphism/inheritance&amp;rdquo;. It wasn&amp;rsquo;t until a few months and some c++ learning resources later, that I was finally able to understand CRTP. In this blogpost, I will talk about CRTP from more of a code generation point of view, and hopefully by then end convince you that &amp;ldquo;static polymorphism/inheritance&amp;rdquo; is a misleading description of this pattern.</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<ul>
<li><!-- raw HTML omitted -->1<!-- raw HTML omitted --> <a href="#how-crtp-works">How CRTP works</a></li>
<li><!-- raw HTML omitted -->2<!-- raw HTML omitted --> <a href="#crtp-is-not-template-programming-magic">CRTP is not &ldquo;template programming magic&rdquo;</a></li>
<li><!-- raw HTML omitted -->3<!-- raw HTML omitted --> <a href="#we-already-have-static-polymorphism">We already have static polymorphism</a></li>
<li><!-- raw HTML omitted -->4<!-- raw HTML omitted --> <a href="#we-already-have-static-implementation-inheritance-dot-dot-dot-except">We already have static implementation inheritance&hellip;Except</a></li>
<li><!-- raw HTML omitted -->5<!-- raw HTML omitted --> <a href="#appendix-dynamic-dispatch">Appendix-Dynamic Dispatch</a></li>
</ul>
<!-- raw HTML omitted -->
<p>On my first encounter, the Curiously Recurring Template Pattern seemed like magic to me. Apparently, by writing <code>static_cast&lt;T*&gt;(this)-&gt;func()</code>,  we now have &ldquo;static polymorphism/inheritance&rdquo;. It wasn&rsquo;t until a few months and some c++ <a href="https://www.youtube.com/watch?v=SShSV%5FiV1Ko">learning resources</a> later, that I was finally able to understand CRTP. In this blogpost, I will talk about CRTP from more of a code generation point of view, and hopefully by then end convince you that &ldquo;static polymorphism/inheritance&rdquo; is a misleading description of this pattern.</p>
<h1 id="how-crtp-works"><!-- raw HTML omitted -->1<!-- raw HTML omitted --> How CRTP works</h1>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BaseT</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> func(){
        <span style="color:#75715e">// Note: the use of pointers instead of references is for pedagogy reasons
</span><span style="color:#75715e"></span>        T<span style="color:#f92672">*</span> derived <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>);
        <span style="color:#75715e">// pre function call code
</span><span style="color:#75715e"></span>        derived<span style="color:#f92672">-&gt;</span>do_func1();
        derived<span style="color:#f92672">-&gt;</span>do_func2();
        <span style="color:#75715e">// post function call code
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> do_func1();
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_func2</span>();
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> do_func1(){};
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_func2</span>(){};
};</code></pre></td></tr></table>
</div>
</div>
<p>Here is the general form of the pattern, with some modifications that will come to light by the end of this article. Let us now walk through what <code>foo</code> translates to for this <code>Derived</code> class. When the compiler processes<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> this function, whose <code>func1</code>  does it insert, <code>BaseT&lt;Derived&gt;</code> or <code>Derived</code>?</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// rough translation
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span>(BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;*</span> <span style="color:#66d9ef">this</span>){
    <span style="color:#75715e">// From now on, generate code as if we have a pointer to Derived(whichc we do)
</span><span style="color:#75715e"></span>    Derived<span style="color:#f92672">*</span> derived <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>);
    <span style="color:#75715e">// pre function call code
</span><span style="color:#75715e"></span>    Derived<span style="color:#f92672">::</span>do_func1(derived);
    Derived<span style="color:#f92672">::</span>do_func2(derived);
    <span style="color:#75715e">// post function call code
</span><span style="color:#75715e"></span>}</code></pre></td></tr></table>
</div>
</div>
<p>The way the C++ object model works is that when there are no virtual functions, the compiler inserts the function corresponding with the <strong>whatever the compile time type CURRENTLY is of the object who calls that method</strong> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
<p>Now, that was a bit of a mouthful. Let us walk through another example of using <code>static_cast</code> to help the compiler with name resolution.</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Parent1</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Parent2</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Child</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Parent1,<span style="color:#66d9ef">public</span> Parent2{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>(){
        Parent2<span style="color:#f92672">*</span> casted <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Parent2<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>);
        casted<span style="color:#f92672">-&gt;</span>f();
        <span style="color:#75715e">// Parent2::f(); // can also be done with explicit scoping
</span><span style="color:#75715e"></span>    }
};</code></pre></td></tr></table>
</div>
</div>
<p>Without the static_cast, the compiler will throw an error, saying <code>f</code> is found in multiple base classes. But by using it, the compiler will no longer look in <code>Child</code> or <code>Parent1</code> during name resolution. One can also use explicit scoping to achieve this, but the difference is that static_cast will walk the class hierarchy until it finds a <code>f</code> . Furthermore explicit scoping requires retyping <code>Parent1</code> on every subsequent member function call.</p>
<p>I find this explanation in terms of &ldquo;manipulating the name resolution path&rdquo; to be much clearer than saying &ldquo;the base class can now access the derived class&rdquo; or &ldquo;we inject the derived class into the base&rdquo; as I have found in other blogs. For all intensive purposes, the compiler thinks it has a Derived object now. And in fact, it is the other way around, that the derived class has access to the base. Which isn&rsquo;t that suprising, as that&rsquo;s basically the definition of how classes work.</p>
<p>So to repeat, after the <code>static_cast</code>, there is no Base anymore. With the fundamental understanding of CRTP down, let us now dispel some myths/confusion around its usage.</p>
<h1 id="crtp-is-not-template-programming-magic"><!-- raw HTML omitted -->2<!-- raw HTML omitted --> CRTP is not &ldquo;template programming magic&rdquo;</h1>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Widget</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;hi&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;};
};
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> generic_function(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> x){
    <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>)<span style="color:#f92672">-&gt;</span>update();
}
<span style="color:#75715e">// vs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> generic_function2(T<span style="color:#f92672">*</span> x){
    x<span style="color:#f92672">-&gt;</span>update();
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
    Widget<span style="color:#f92672">*</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Widget;
    generic_function<span style="color:#f92672">&lt;</span>Widget<span style="color:#f92672">&gt;</span>((<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)x);
    generic_function2(x);
}</code></pre></td></tr></table>
</div>
</div>
<p>Consider the above example. They both will print &ldquo;hi&rdquo;. The difference is just that we gave the first one a bad input argument, and so we had to &ldquo;compensate&rdquo; via the static_cast. So if you understand static_cast and basic generic programming<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>
there is no reason you shouldn&rsquo;t understand CRTP.</p>
<h1 id="we-already-have-static-polymorphism"><!-- raw HTML omitted -->3<!-- raw HTML omitted --> We already have static polymorphism</h1>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">34
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">35
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">36
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">37
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">38
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">39
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">40
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">41
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">42
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">43
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">44
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">45
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">46
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Object1</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> interface(){
        <span style="color:#75715e">// pre function call code
</span><span style="color:#75715e"></span>        impl();
        <span style="color:#75715e">// post function call code
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
   <span style="color:#66d9ef">void</span> impl(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;a&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Object2</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> interface(){
        <span style="color:#75715e">// Notice we call whatever functions we want here, unlike CRTP
</span><span style="color:#75715e"></span>        impl_a();
        impl_b();
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> impl_a(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b1&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">impl_b</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;b2&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
};
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BaseT</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">interface</span>(){
        <span style="color:#75715e">// pre function call code
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>)<span style="color:#f92672">-&gt;</span>impl();
        <span style="color:#75715e">// post function call code
</span><span style="color:#75715e"></span>    }
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">impl</span>(){cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;c&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;}
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> call_a_function(T<span style="color:#f92672">&amp;</span> x){
    x.interface();
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
    Object1 a;
    Object2 b;
    Derived c;
    call_a_function(a);<span style="color:#75715e">// They all work!
</span><span style="color:#75715e"></span>    call_a_function(b);
    call_a_function(c);
}</code></pre></td></tr></table>
</div>
</div>
<p>As we can see, CRTP is not necessary here(and actually is not even a &ldquo;true&rdquo; interface in some sense, as it has already predetermined the implementation). What is really giving us polymorphism is generic programming. Furthermore, inheriting from a CRTP doesn&rsquo;t actually guarantee the Derived class will satisfy the interface. Consider this example</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BaseT</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>(){
        <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">*&gt;</span>(<span style="color:#66d9ef">this</span>)<span style="color:#f92672">-&gt;</span>not_implemented();
    }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>{
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span>{
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">D</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> B{
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
    Derived a;
    D b;
}</code></pre></td></tr></table>
</div>
</div>
<p>Comment out the <code>D b;</code> initialization in main, and the code compiles. With it, we get an error. Why? Because abstract base classes force their inheritors to implement the interface, even if the function never gets called. There are no such guarantees, however, with CRTP.(If we do call Derived&rsquo;s <code>f</code> function, we will get an error&hellip;but we basically get the same error had <code>f</code> been a templated free function)<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup></p>
<h1 id="we-already-have-static-implementation-inheritance-dot-dot-dot-except"><!-- raw HTML omitted -->4<!-- raw HTML omitted --> We already have static implementation inheritance&hellip;Except</h1>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">EngineMixin</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_work</span>();
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SpecificEngine</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> EngineMixin{
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BaseT</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_work</span>();
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>{
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>){
    SpecificEngine e;
    Derived d;
    e.work(); <span style="color:#75715e">//They both static dispatch to the same thing!
</span><span style="color:#75715e"></span>    d.work();
}</code></pre></td></tr></table>
</div>
</div>
<p>Let us now consider the other aspect of inheritance, inheritance of functionality. In the above example, <code>SpecificEngine</code> and <code>Derived</code> will both resolve the function call at compile time, as there are no <a href="#appendix-dynamic-dispatch">virtual functions + pointers here</a>. I would like to emphasis this, as I feel some people may think that just because there is a &ldquo;static_cast&rdquo; in CRTP, it is somehow related to the function call being static too. As I have explained above, <code>static_cast</code> <strong>controls what name we dispatch to, and not the type of the dispatch</strong></p>
<p>So given all of this, when exactly should we use CRTP? Let us reconsider the initial example</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BaseT</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> func(){
        <span style="color:#75715e">// pre function call code
</span><span style="color:#75715e"></span>        derived<span style="color:#f92672">-&gt;</span>do_func1();
        derived<span style="color:#f92672">-&gt;</span>do_func2();
        <span style="color:#75715e">// post function call code
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> do_func1();
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_func2</span>();
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> BaseT<span style="color:#f92672">&lt;</span>Derived<span style="color:#f92672">&gt;</span>{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> do_func1(){};
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do_func2</span>(){};
};</code></pre></td></tr></table>
</div>
</div>
<p>Now, if you look closely, I haven&rsquo;t actually reproduced the initial example! Instead, by removing the static_cast and adding <code>virtual</code> to <code>do_func1/do_func2</code>, I have actually introduced another pattern, known as the &ldquo;NVI idiom&rdquo; or Facade Design Pattern. The purpose of this pattern is the Base class provides most of the code scaffolding/wiring/or public interface, and the Derived class simply needs to &ldquo;fill in the blanks&rdquo;. So if you have been wondering why I have been writing &ldquo;pre function call&rdquo; comments throughout this post, it is because <strong>I want to encourage you to think of CRTP as a &ldquo;static NVI idiom&rdquo;</strong>, and not &ldquo;static inheritance&rdquo;. If all the Base class does is forward to the implementation, one has to wonder &ldquo;What was the point?&rdquo;</p>
<p>As long as you keep this in mind, CRTP should be hard to abuse and then subsequently &ldquo;shoot yourself in the foot&rdquo; with it.</p>
<hr>
<h1 id="appendix-dynamic-dispatch"><!-- raw HTML omitted -->5<!-- raw HTML omitted --> Appendix-Dynamic Dispatch</h1>
<p>(Note: This section may or may not be helpful in understanding how CRTP works. )</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span>{
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">walk</span>();
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">eat</span>()  ;
    <span style="color:#66d9ef">int</span> data;
};
<span style="color:#75715e">// is roughly
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Animal</span>{
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> _vtable;
    <span style="color:#66d9ef">int</span> data;
};
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">update</span>(Animal<span style="color:#f92672">*</span>){};</code></pre></td></tr></table>
</div>
</div>
<p>When you declare a virtual function inside the `Animal` class in C++, the compile will add a pointer inside every created object that points to the same location: the start of `Animal` vtable. In this region of memory, every 8 byte interval(the size of a pointer) will correspond with the address of a virtual function for this object. When virtual functions get called, the following translation happens</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Note: the use of raw pointers is for pedagogy reasons
</span><span style="color:#75715e"></span>Animal<span style="color:#f92672">*</span> animal <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Animal;
animal<span style="color:#f92672">-&gt;</span>eat();
<span style="color:#75715e">// is roughly
</span><span style="color:#75715e"></span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>animal._vtable<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>byte))(animal); <span style="color:#75715e">// 1byte offset to get to 2nd virtual function
</span></code></pre></td></tr></table>
</div>
</div>
<p>Note the <code>w</code> is a pointer. Had we declare it as variable, static dispatch would have to happen, even if the <strong>function was declared virtual</strong>. I won&rsquo;t go completely into detail as to why here, but let&rsquo;s just say that given <code>animal</code> is declared on the stack, there is no way to &ldquo;lie&rdquo; and say it is anything but an <code>Animal</code></p>
<p>Finally, the way that this indirection allows for polymorphism is that the dynamic dispatch translation is the same <strong>regardless of what the Animal pointer actually points to</strong></p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">
<table style="border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Dog</span><span style="color:#f92672">:</span><span style="color:#66d9ef">public</span> Animal{
    <span style="color:#66d9ef">virtual</span> <span style="color:#a6e22e">eat</span>(){
        <span style="color:#75715e">//something different
</span><span style="color:#75715e"></span>    }
}

Animal<span style="color:#f92672">*</span> dog <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Dog;
dog<span style="color:#f92672">-&gt;</span>eat();
<span style="color:#75715e">// is roughly
</span><span style="color:#75715e"></span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span>dog._vtable<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>byte))(dog);

<span style="color:#75715e">// so basically the same as
</span><span style="color:#75715e">// (*(*animal._vtable+1byte))(animal);
</span></code></pre></td></tr></table>
</div>
</div>
<p>The difference is that the vtable now holds different information. Namely <code>*dog._vtable+1byte</code> now stores the location of <code>Dog::eat()</code> rather than <code>Animal::eat()</code></p>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p>Or more precisely decides it is necessary to construct this function&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p>Let&rsquo;s ignore walking the class hierarchy for now&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p>There are no variadic templates, enable_if, or other hocus pocus happening here&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p>I will admit that CRTP provides better lookup access to the functionality that a class has, compared to free functions. But unless there is &ldquo;scaffolding&rdquo; code, this can also be done by creating public member functions or just supplying the free functions in the same header as the class&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>
]]></content>
        </item>
        
    </channel>
</rss>
